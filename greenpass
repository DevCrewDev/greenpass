#!/usr/bin/env python3

# Green Pass Parser
# Copyright (C) 2021  Davide Berardi -- <berardi.dav@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import io
import os
import sys
import zlib
import fitz
import json
import pytz
import cbor2
import base45
import base64
import pickle
import argparse
import requests
import colorama
import functools
from PIL import Image
from pyzbar import pyzbar
from OpenSSL import crypto
from binascii import hexlify
from datetime import datetime
from cose.keys import EC2Key, CoseKey
from cose.headers import KID
from cose.messages import CoseMessage

# Colored output
color = False
# Settings output
settings = False
# QR Code file
qrfile = None
# Read text file from stdin
txt = None
# PDF File
pdffile = None
# Base url to retrieve data (DGC)
BASE_URL_DGC   = "https://get.dgc.gov.it/v1/dgc/"
# Base url to retrieve data (NHS)
BASE_URL_NHS   = "https://covid-status.service.nhsx.nhs.uk/"
TESTS_URL = "https://covid-19-diagnostics.jrc.ec.europa.eu/devices/export?manufacturer=&text_name=&marking=&rapid_diag=&format=&target_type=&field-1=HSC%20common%20list%20%28RAT%29&value-1=1&search_method=AND"

# Cache Directory
DEFAULT_CACHE_DIR=functools.reduce(
    os.path.join,
    [ os.path.expanduser("~"), ".local", "greenpass" ]
)

# Output Manager, manages output and dumps to files and stdout
class OutputManager(object):

    def __init__(self):
        self.out = ""

    def add_general_info(self, infoname, infoval):
        self.out += "{:30s} {}\n".format(infoname, infoval)

    def add_cert_info(self, infoname, infoval):
        self.out += "  {:28s} {}\n".format(infoname, infoval)

    def add_general_info_ok(self, infoname, infoval):
        self.add_general_info(infoname, colored(infoval, "green"))

    def add_general_info_info(self, infoname, infoval):
        self.add_general_info(infoname, colored(infoval, "blue"))

    def add_general_info_warning(self, infoname, infoval):
        self.add_general_info(infoname, colored(infoval, "yellow"))

    def add_general_info_error(self, infoname, infoval):
        self.add_general_info(infoname, colored(infoval, "red"))

    def add_cert_info_ok(self, infoname, infoval):
        self.add_cert_info(infoname, colored(infoval, "green"))

    def add_cert_info_info(self, infoname, infoval):
        self.add_cert_info(infoname, colored(infoval, "blue"))

    def add_cert_info_warning(self, infoname, infoval):
        self.add_cert_info(infoname, colored(infoval, "yellow"))

    def add_cert_info_error(self, infoname, infoval):
        self.add_cert_info(infoname, colored(infoval, "red"))

    def add_remaining_time(self, certtype, certdate, level, remaining_days):
        if level == 0:
            color = "white"
        if level == 1:
            color = "green"
        if level == 2:
            color = "yellow"
        if level == 3:
            color = "red"

        self.out += "  {:28s} {} ({})\n".format(
            "{} Date".format(certtype),
            colored(certdate, color), colored(remaining_days, color)
        )

    def get_not_yet_valid(self, remaining_hours):
        return "Not yet valid, {:.0f} hours to validity, {} days".format(
                hours_to_valid, int(hours_to_valid / 24)
        )

    def get_expired(self, remaining_hours):
        return "Expired since {:.0f} hours, {} days".format(
                    -remaining_hours,
                    -int(remaining_hours / 24)
                )
    def get_hours_left(self, remaining_hours):
        return "{:.0f} hours left ({} days)".format(
                    remaining_hours,
                    int(remaining_hours / 24)
                )

    def get_months_left(self, remaining_hours):
        return "{:.0f} hours left, {} days, ~ {} months".format(
                remaining_hours,
                int(remaining_hours / 24),
                round(remaining_hours / 24 / 30)
        )

    def dump(self, file=sys.stdout):
        print(self.out, file=file)


    def dump_settings(self):
        sm = SettingsManager()

        print("Tests")
        for el in sm.test.items():
            print("  {} not before: {:4d} hours   not after: {:4d} hours".format(
                colored("{:25s}".format(el[0]), "blue"), el[1]["start_hours"], el[1]["end_hours"])
            )
        print()
        print("Certifications")
        print("  {} not before: {:4d} days    not after: {:4d} days".format(
            colored("{:25s}".format("recovery"), "blue"), sm.recovery["start_day"], sm.recovery["end_day"])
        )
        print()

        print("Vaccines")
        for vac in sm.vaccines.items():
            for el in vac[1].items():
                print("  {} {} not before: {:4d} days    not after: {:4d} days".format(
                    colored("{:12s}".format(el[0]), "blue"),
                    colored("{:12s}".format(Vaccine(vac[0]).get_pretty_name()), "yellow"),
                    el[1]["start_day"], el[1]["end_day"]
                    )
                )
        print()


class TestType(object):
    def __init__(self, t):
        self.t = t
        self._type = {
            "LP6464-4":   "molecular",
            "LP217198-3": "rapid"
        }
        self.pretty_name = self._type

    def get_type(self):
        return self._type.get(self.t, self.t)

    def get_pretty_name(self):
        return self.pretty_name.get(self.t, self.t)

class TestResult(object):
    def __init__(self, t):
        self.t = t

    def is_positive(self):
        return self.t == 260373001

    def is_negative(self):
        return self.t == 260415000

    def is_aladeen(self):
        return not self.is_positive() and not self.is_negative()

    def is_unknown(self):
        return self.is_aladeen()

    def __str__(self):
        if self.is_positive():
            return colored("Positive", "red")
        elif self.is_negative():
            return colored("Negative", "green")
        return colored("Unknown", "yellow")

# Manufacturer names
class Manufacturer(object):
    def __init__(self, t, cachedir=''):
        self.t = t
        # Vaccines
        self.pretty_name = {
            "ORG-100001699": "AstraZeneca",
            "ORG-100030215": "Biontech",
            "ORG-100001417": "Janssen",
            "ORG-100031184": "Moderna",
            "ORG-100006270": "Curevac",
            "ORG-100013793": "CanSino",
            "ORG-100020693": "Sinopharm",
            "ORG-100010771": "Sinopharm",
            "ORG-100024420": "Sinopharm",
            "ORG-100032020": "Novavax"
        }
        # Testes
        if cachedir == '':
            self.pretty_name.update(self.get_tests_pn())
        else:
            self.pretty_name.update(self.get_cached_tests_pn(cachedir))

    def get_tests_pn(self):
        o = {}
        r = requests.get(TESTS_URL)
        if r.status_code != 200:
            return o
        l = json.loads(r.text)
        for el in l:
            o[el["id_device"]] = el["commercial_name"]

        return o

    def get_cached_tests_pn(self, cachedir):
        testcache = os.path.join(cachedir, "tests")

        if not os.path.exists(cachedir):
            os.mkdir(cachedir)

        if not os.path.exists(testcache):
            with open(testcache, 'wb') as f:
                pickle.dump(self.get_tests_pn(), f)

        with open(testcache, 'rb') as f:
            tests = pickle.load(f)

        return tests

    def get_pretty_name(self):
        return self.pretty_name.get(self.t, self.t)


# Vaccine names
class Vaccine(object):
    def __init__(self, t):
        self.t = t
        self.pretty_name = {
            "EU/1/20/1507": "Moderna",
            "EU/1/20/1525": "Janssen",
            "EU/1/20/1528": "Pfizer",
            "EU/1/21/1529": "AstraZeneca",
            "EU/1/XX/XXX1": "Sputnik-V",
            "EU/1/XX/XXX2": "CVnCoV",
            "EU/1/XX/XXX3": "EpiVacCorona",
            "EU/1/XX/XXX4": "BBIBP-CorV",
            "EU/1/XX/XXX5": "CoronaVac",
        }
    def get_pretty_name(self):
        return self.pretty_name.get(self.t, self.t)

# Disease names
class Disease(object):
    def __init__(self, t):
        self.t = t
        self.pretty_name = {
            "840539006": "Covid19"
        }
    def get_pretty_name(self):
        return self.pretty_name.get(self.t, self.t)

# Retrieve settings from unified API endpoint
class SettingsManager(object):
    def __init__(self, cachedir=''):
        if cachedir != '':
            self.get_cached_settings()
        else:
            self.get_settings()

    def get_cached_settings(self):
        settings = os.path.join(cachedir, "settings")

        if not os.path.exists(cachedir):
            os.mkdir(cachedir)

        if not os.path.exists(settings):
            with open(settings, 'wb') as f:
                pickle.dump(self.get_settings(), f)

        with open(settings, 'rb') as f:
            self.vaccines, self.recovery, self.test = pickle.load(f)

    def get_settings(self):
        r = requests.get("{}/settings".format(BASE_URL_DGC))
        if r.status_code!=200:
            print("[-] Error from API")
            sys.exit(1)

        self.vaccines = {}
        self.recovery = {}
        self.test    = {
            "molecular": {},
            "rapid": {}
        }

        settings = json.loads(r.text)
        # Dispatch and create the dicts
        for el in settings:
            if "vaccine" in el["name"]:
                if self.vaccines.get(el["type"], None) == None:
                    self.vaccines[el["type"]] = {
                        "complete": {
                            "start_day": -1,
                            "end_day": -1
                        },
                        "not_complete": {
                            "start_day": -1,
                            "end_day": -1
                        }
                    }
                if "not_complete" in el["name"]:
                    vtype = "not_complete"
                elif "complete" in el["name"]:
                    vtype = "complete"

                if "start_day" in el["name"]:
                    daytype = "start_day"
                elif "end_day" in el["name"]:
                    daytype = "end_day"

                self.vaccines[el["type"]][vtype][daytype] = int(el["value"])

            elif "recovery" in el["name"]:
                if "start_day" in el["name"]:
                    self.recovery["start_day"] = int(el["value"])
                elif "end_day" in el["name"]:
                    self.recovery["end_day"] = int(el["value"])

            elif "test" in el["name"]:
                if "molecular" in el["name"]:
                    ttype = "molecular"
                elif "rapid" in el["name"]:
                    ttype = "rapid"

                if "start_hours" in el["name"]:
                    hourtype = "start_hours"
                elif "end_hours" in el["name"]:
                    hourtype = "end_hours"

                self.test[ttype][hourtype] = int(el["value"])
            elif "ios" == el["name"] or "android" == el["name"]:
                # Ignore app specific options
                pass
            else:
                print("[~] Unknown field {}".format(el["name"]))
        return self.vaccines, self.recovery, self.test

    # Return the time that a test is still valid, negative time if expired
    def get_test_remaining_time(self, test_date, ttype):
        hours = self.test.get(ttype, 0)

        try:
            seconds_since_test = (datetime.now(pytz.utc) - test_date).total_seconds()
            hours_since_test = seconds_since_test / (60 * 60)
        except:
            return 0,0

        valid_start = (hours_since_test - hours["start_hours"])
        valid_end   = (hours["end_hours"] - hours_since_test)

        return valid_start, valid_end

    # Return the time that a vaccine is still valid, negative
    # time if expired
    def get_vaccine_remaining_time(self, vaccination_date, vtype, full):
        if full:
            selector = "complete"
        else:
            selector = "not_complete"

        days = self.vaccines.get(vtype, { "complete": 0, "not_complete": 0})[selector]

        try:
            seconds_since_vaccine = (datetime.now(pytz.utc) - vaccination_date).total_seconds()
            hours_since_vaccine = seconds_since_vaccine / (60 * 60)
        except:
            return 0,0

        valid_start = (hours_since_vaccine - days["start_day"] * 24)
        valid_end   = (days["end_day"] * 24 - hours_since_vaccine)

        return int(valid_start), int(valid_end)

    # Return the time that a recovery certification is still valid, negative
    # time if expired
    def get_recovery_remaining_time(self, recovery_from, recovery_until):
        days = self.recovery

        try:
            seconds_since_recovery = (datetime.now(pytz.utc) - recovery_from).total_seconds()
            hours_since_recovery = seconds_since_recovery / (60 * 60)
        except:
            return 0,0

        valid_start = (hours_since_recovery - days["start_day"] * 24)
        valid_end   = (days["end_day"] * 24 - hours_since_recovery)

        valid_until = (recovery_until - datetime.now(pytz.utc)).total_seconds()
        valid_until = valid_until / (60 * 60)

        valid_end = min(valid_end, valid_until)

        return int(valid_start), int(valid_end)

# Update certificate signer
class CertificateUpdater(object):
    def __init__(self):
        pass

    # Get KEY index from online status page
    def _get_kid_idx(self, kid, _type="dgc"):
        if _type == "dgc":
            r = requests.get("{}/signercertificate/status".format(BASE_URL_DGC))
        elif _type == "nhs":
            r = requests.get("{}/pubkeys/keys.json".format(BASE_URL_NHS))
        else:
            return ("unk", -1)
        if r.status_code != 200:
            print("[-] Error from API")
            sys.exit(1)
        i = 0
        hexkid = hexlify(kid)
        for x in json.loads(r.text):
            if _type == "dgc":
                targetkid = hexlify(base64.b64decode(x))
            if _type == "nhs":
                targetkid = hexlify(base64.b64decode(x["kid"]))
            if targetkid == hexkid:
                return (_type, i)
            i += 1
        return (_type, -1)

    # Dispatch to correct Key IDX retrieve function
    def get_kid_idx(self, kid):
        k = self._get_kid_idx(kid, "nhs")
        if k[1] != -1:
            return k
        k = self._get_kid_idx(kid, "dgc")
        if k[1] != -1:
            return k

        print("[-] Could not find certification authority")
        sys.exit(1)

    # Get key from DGC style repository
    def get_key_dgc(self, idx):
        headers = { "x-resume-token": str(idx) }
        r = requests.get("{}/signercertificate/update".format(BASE_URL_DGC), headers=headers)
        if r.status_code != 200:
            print("[-] Error from API")
            sys.exit(1)

        certificate = base64.b64decode(r.text)
        return certificate

    # Return public key
    def loadpubkey(self, certificate):
        # Load certificate and dump the pubkey
        x509 = crypto.load_certificate(crypto.FILETYPE_ASN1, certificate)
        pubkey = crypto.dump_publickey(crypto.FILETYPE_ASN1, x509.get_pubkey())[26::]
        return pubkey

    # Get key from NHS style repository
    def get_key_nhs(self, idx):
        r = requests.get("{}/pubkeys/keys.json".format(BASE_URL_NHS))
        for x in json.loads(r.text):
            targetkid = hexlify(base64.b64decode(x["kid"]))
            if targetkid == hexkid:
                return base64.b64decode(x["publicKey"])

    # Retrieve key from remote repository
    def get_key(self, kid):
        keytype, idx = self.get_kid_idx(kid)

        if keytype == "dgc":
            pubkey = self.get_key_dgc(idx)
        elif keytype == "nhs":
            pubkey = self.get_key_nhs(idx)
        return pubkey

    # Retrieve key and convert to coseobj
    def get_key_coseobj(self, kid):
        certificate = self.get_key(kid)
        pubkey = self.loadpubkey(certificate)
        return self.getcoseobj(pubkey)

    # Return COSE object from public key
    def getcoseobj(self, pubkey):
        # X is the first 32 bits, Y are the remaining ones
        x = pubkey[1:int(len(pubkey)/2) + 1]
        y = pubkey[int(len(pubkey)/2) + 1::]

        # Create COSE key
        kattr = {
                "KTY":   "EC2",
                "CURVE": "P_256",
                "ALG":   "ES256",
                "X":     x,
                "Y":     y
        }
        return CoseKey.from_dict(kattr)

# Cached version of Certificate Updater,
#  saves and retrieves public keys using a cache directory
class CachedCertificateUpdater(CertificateUpdater):
    def __init__(self, cachedir):
        self.cachedir = cachedir
        if not os.path.exists(cachedir):
            try:
                os.mkdir(cachedir)
            except FileExistsError:
                pass

    def get_key(self, kid):
        enckid = base64.b64encode(kid).decode()
        cachepath = os.path.join(self.cachedir, enckid)
        superclass = super(CachedCertificateUpdater, self)

        if not os.path.exists(cachepath):
            with open(cachepath, "wb") as f:
                f.write(superclass.get_key(kid))

        with open(cachepath, "rb") as f:
            keybytes = f.read()

        return keybytes

# Class to get input data from various sources.
# Current supported:
# TXT Data
# PNG Image
# PDF Documents
class InputTransformer(object):
    def __init__(self, path, filetype):
        if filetype == "txt":
            if path == "-":
                outdata = bytes(sys.stdin.read().split("\n")[0].encode("ASCII"))
            else:
                with open(path, 'rb') as f:
                    outdata = f.read()
        else:
            if filetype == "png":
                img = Image.open(path)
            elif filetype == "pdf":
                # Convert PDF to JPG
                pdf_file = fitz.open(path)
                imagebytes = pdf_file.extractImage(6)["image"]
                img = Image.open(io.BytesIO(imagebytes))
            else:
                print("[-] file format {} not recognized".format(filetype), file=sys.stderr)

            decoded = pyzbar.decode(img)
            if len(decoded) < 1:
                print("[-] Value not found", file=sys.stderr)
                sys.exit(1)
            output = decoded[0]
            if output.type != "QRCODE":
                print("[-] Not a qrcode", file=sys.stderr)
                sys.exit(1)

            outdata = output.data
        self.data = outdata

    def get_data(self):
        return self.data

# Static class with common keys for
# printing and addressing in the qrcode
# Can also be localized
class GreenPassKeyManager(object):
    def __init__(self):
        pass

    # The first value of these tuples is the key in the qrcode,
    # the second is the localized info
    def get_release_country(self):
        return ( 1, "Release Country" )

    def get_release_date(self):
        return ( 6, "Release Date" )

    def get_expiration_date(self):
        return ( 4, "Expiration Date" )

    def get_version(self):
        return ( "ver", "Version" )

    def get_date_of_birth(self):
        return ( "dob", "Date of Birth" )

    def get_name(self):
        return ( "nam", "Name" )

    def get_personal_data(self):
        return ( -260, "Personal Data" )

    def get_personal_info(self):
        return ( 1, "Personal Info" )

    def get_first_name(self):
        return ( "gn", "First Name" )

    def get_last_name(self):
        return ( "fn", "Family Name" )

    def get_vaccine(self):
        return ( "v", "Vaccine" )

    def get_test(self):
        return ( "t", "Test" )

    def get_recovery(self):
        return ( "r", "Recovery" )

    def get_target_disease(self):
        return ( "tg", "Target Disease" )

    def get_vaccination_country(self):
        return ( "co", "Vaccination or Test Country" )

    def get_certificate_issuer(self):
        return ( "is", "Certificate Issuer" )

    def get_certificate_id(self):
        return ( "ci", "Certificate ID" )

    def get_first_positive_test(self):
        return ( "fr", "First Positive Test" )

    def get_validity_from(self):
        return ( "df", "Validity From" )

    def get_validity_until(self):
        return ( "df", "Validity Until" )

    def get_manufacturer(self):
        return ( "ma", "Manufacturer and Type" )

    def get_test_type(self):
        return ( "tt", "Test type" )

    def get_test_name(self):
        return ( "tn", "Test name" )

    def get_date_of_collection(self):
        return ( "sc", "Date of collection" )

    def get_test_result(self):
        return ( "tr", "Test result" )

    def get_testing_center(self):
        return ( "tc", "Testing center" )

    def get_dose_number(self):
        return ( "dn", "Dose Number" )

    def get_total_doses(self):
        return ( "sn", "Total Doses" )

    def get_vaccine_pn(self):
        return ( "mp", "Vaccine Product Number" )

    def get_vaccine_type(self):
        return ( "vp", "Vaccine Type" )

    def get_vaccination_date(self):
        return ( "dt", "Vaccination Date" )

    def get_certificate_type(self):
        return ( "", "Certificate Type" )

    def get_verified(self):
        return ( "", "Verified" )

    def get_cert_type_long_name(self, t):
        if t == self.get_vaccine()[0]:
            return self.get_vaccine()[1]
        if t == self.get_test()[0]:
            return self.get_test()[1]
        if t == self.get_recovery()[0]:
            return self.get_recovery()[1]


class UnrecognizedException(Exception):
    def __init__(self, m):
        return super(UnrecognizedException, self).__init__(m)

# Parse a green pass file
class GreenPassParser(object):
    def __init__(self, certification, k=GreenPassKeyManager()):
        # Remove the initial HC1: part and decode the certificate
        data = b":".join(certification.split(b":")[1::])
        decoded = base45.b45decode(data)
        uncompressed = zlib.decompress(decoded)

        # Get the COSE message
        self.cose = CoseMessage.decode(uncompressed)

        # Extract kid and payload
        self.kid = self.get_kid_from_cose(self.cose.phdr)
        self.payload = cbor2.loads(self.cose.payload)

        self.qr_info = {
            k.get_release_country()[1]: self.payload[k.get_release_country()[0]],
            k.get_release_date()[1]:    int(self.payload[k.get_release_date()[0]]),
            k.get_expiration_date()[1]: int(self.payload[k.get_expiration_date()[0]]),
        }

        personal_data = self.payload[k.get_personal_data()[0]][k.get_personal_info()[0]]
        self.personal_info = {
            k.get_version()[1]:       personal_data[k.get_version()[0]],
            k.get_date_of_birth()[1]: personal_data[k.get_date_of_birth()[0]],
            k.get_first_name()[1]:    personal_data[k.get_name()[0]][k.get_first_name()[0]],
            k.get_last_name()[1]:     personal_data[k.get_name()[0]][k.get_last_name()[0]],
        }

        self.certificate_info = []
        if personal_data.get(k.get_vaccine()[0], None) != None:
            # Vaccine
            self.certificate_type = k.get_vaccine()[0]
        elif personal_data.get(k.get_test()[0], None) != None:
            # Test
            self.certificate_type = k.get_test()[0]
        elif personal_data.get(k.get_recovery()[0], None) != None:
            # Recovery
            self.certificate_type = k.get_recovery()[0]
        else:
            raise UnrecognizedException("Unrecognized certificate type")

        for el in personal_data[self.certificate_type]:
            cert = {
                # Common
                k.get_target_disease()[1]:      el[k.get_target_disease()[0]],
                k.get_vaccination_country()[1]: el[k.get_vaccination_country()[0]],
                k.get_certificate_issuer()[1]:  el[k.get_certificate_issuer()[0]],
                k.get_certificate_id()[1]:      el[k.get_certificate_id()[0]],
                # Recovery
                k.get_first_positive_test()[1]: el.get(k.get_first_positive_test()[0], None),
                k.get_validity_from()[1]:       el.get(k.get_validity_from()[0], None),
                k.get_validity_until()[1]:      el.get(k.get_validity_until()[0], None),
                # Common for Test and Vaccine
                k.get_manufacturer()[1]:        el.get(k.get_manufacturer()[0], None),
                # Test
                k.get_test_type()[1]:           el.get(k.get_test_type()[0], None),
                k.get_test_name()[1]:           el.get(k.get_test_name()[0], None),
                k.get_date_of_collection()[1]:  el.get(k.get_date_of_collection()[0], None),
                k.get_test_result()[1]:         el.get(k.get_test_result()[0], None),
                k.get_testing_center()[1]:      el.get(k.get_testing_center()[0], None),
                # Vaccine
                k.get_dose_number()[1]:         int(el.get(k.get_dose_number()[0], 0)),
                k.get_total_doses()[1]:         int(el.get(k.get_total_doses()[0], 0)),
                k.get_vaccine_pn()[1]:          el.get(k.get_vaccine_pn()[0], None),
                k.get_vaccine_type()[1]:        el.get(k.get_vaccine_type()[0], None),
                k.get_vaccination_date()[1]:    el.get(k.get_vaccination_date()[0], None)
            }
            self.certificate_info.append(cert)

    # Isolate KID from COSE object
    def get_kid_from_cose(self, phdr):
        for k in phdr.keys():
            if (k == type(KID())):
                return phdr[k]
        print("Could not find KID", file=sys.stderr)
        return None

    # Get Key ID from the QRCode
    def get_kid(self):
        return self.kid

    # Set the decryption key
    def set_key(self, key):
        self.cose.key = key

    # Verify the code
    def verify(self):
        return self.cose.verify_signature()

    # Dump the content of the payload in JSON format
    def dump(self, file=sys.stdout):
        print(json.dumps(self.payload), file=file)

# Logic Manager, retrieve information from the certificate and set
#  output.
class LogicManager(object):

    def __init__(self):
        pass

    # Verify certificate
    def verify_certificate(self,
                           output,
                           cachedir='',
                           raw=False,
                           k=GreenPassKeyManager()):
        dn = -1
        sd = -1

        vaccinedate = None
        recovery_from  = None
        recovery_until = None
        testcollectiondate = None

        expired = True
        vaccine = None
        positive = False
        hours_to_valid = None
        testtype = None
        remaining_hours = None

        certificate_type = k.get_cert_type_long_name(gpp.certificate_type)
        output.add_general_info_info(k.get_certificate_type()[1], certificate_type)

        for qr_info in gpp.qr_info.items():
            if qr_info[0] == k.get_release_date()[1] or qr_info[0] == k.get_expiration_date()[1]:
                output.add_general_info(qr_info[0], datetime.fromtimestamp(qr_info[1], pytz.utc))
            else:
                output.add_general_info(qr_info[0], qr_info[1])

        for personal_info in gpp.personal_info.items():
            output.add_general_info(personal_info[0], personal_info[1])

        # Invalid GP, more than one certificate info
        if len(gpp.certificate_info) > 1:
            return 1

        el = gpp.certificate_info[0]

        for cert_info in tuple(filter(lambda x: x[1] != None, el.items())):
            if cert_info[0] == k.get_dose_number()[1]:
                dn = cert_info[1]
            elif cert_info[0] == k.get_test_result()[1]:
                t = TestResult(int(cert_info[1]))
                # Strict check, also unknown do not get validated
                positive = not t.is_negative()
                output.add_cert_info(cert_info[0], t)
            elif cert_info[0] == k.get_validity_from()[1]:
                try:
                    recovery_from = datetime.strptime(cert_info[1], "%Y-%m-%d")
                    recovery_from = pytz.utc.localize(recovery_from, is_dst=None).astimezone(pytz.utc)
                except:
                    recovery_from = 0
            elif cert_info[0] == k.get_validity_until()[1]:
                try:
                    recovery_until = datetime.strptime(cert_info[1], "%Y-%m-%d")
                    recovery_until = pytz.utc.localize(recovery_until, is_dst=None).astimezone(pytz.utc)
                except:
                    recovery_until = 0
                certdate = recovery_from
            elif cert_info[0] == k.get_total_doses()[1]:
                sd = cert_info[1]
            elif cert_info[0] == k.get_vaccine_pn()[1]:
                vaccine = cert_info[1]
                output.add_cert_info_info(cert_info[0], Vaccine(cert_info[1]).get_pretty_name())
            elif cert_info[0] == k.get_test_type()[1]:
                testtype = cert_info[1]
                output.add_cert_info_info(cert_info[0], TestType(cert_info[1]).get_pretty_name())
            elif cert_info[0] == k.get_vaccination_date()[1]:
                try:
                    vaccinedate = datetime.strptime(cert_info[1], "%Y-%m-%d")
                    vaccinedate = pytz.utc.localize(vaccinedate, is_dst=None).astimezone(pytz.utc)
                except:
                    vaccinedate = 0
                certdate  = vaccinedate
            elif cert_info[0] == k.get_date_of_collection()[1]:
                try:
                    testcollectiondate = datetime.strptime(cert_info[1], "%Y-%m-%dT%H:%M:%S%z")
                except:
                    testcollectiondate = 0
                certdate = testcollectiondate
            elif cert_info[0] == k.get_manufacturer()[1]:
                output.add_cert_info_info(cert_info[0], Manufacturer(cert_info[1]).get_pretty_name())
            elif cert_info[0] == k.get_target_disease()[1]:
                output.add_cert_info_info(cert_info[0], Disease(cert_info[1]).get_pretty_name())
            else:
                output.add_cert_info(cert_info[0], cert_info[1])

        # Complex fields parse
        if dn > 0 and sd > 0:
            if dn == sd:
                output.add_cert_info_ok(k.get_doses()[1], "{}/{}".format(dn, sd))
            elif dn < sd and dn != 0:
                output.add_cert_info_warning(k.get_doses()[1], "{}/{}".format(dn, sd))

        # Check test validity
        if testcollectiondate != None and testtype != None:
            level = 0
            ttype = TestType(testtype)
            hours_to_valid, remaining_hours = sm.get_test_remaining_time(testcollectiondate, ttype.get_type())

        # Check vaccine validity
        if vaccinedate != None and vaccine != None:
            level = 0
            hours_to_valid, remaining_hours = sm.get_vaccine_remaining_time(vaccinedate, vaccine, dn == sd)

        # Check recovery validity
        if recovery_from != None and recovery_until != None:
            level = 0
            hours_to_valid, remaining_hours = sm.get_recovery_remaining_time(recovery_from, recovery_until)

        if hours_to_valid != None and remaining_hours != None:
            if hours_to_valid < 0:
                level = 3
                remaining_hours = output.get_not_yet_valid(hours_to_valid)
                remaining_days = output.get_not_yet_valid(hours_to_valid)
                expired = True
            elif remaining_hours <= 0:
                level = 3
                remaining_days = output.get_expired(remaining_hours)
                expired = True
            elif remaining_hours * 24 < 14:
                level = 2
                remaining_hours = output.get_hours_left(remaining_hours)
                remaining_days = remaining_hours
                expired = False
            else:
                level = 1
                remaining_days = output.get_months_left(remaining_hours)
                expired = False

            output.add_remaining_time(certificate_type, certdate, level, remaining_days)

        if cachedir != '':
            cup = CachedCertificateUpdater(cachedir)
        else:
            cup = CertificateUpdater()
        key = cup.get_key_coseobj(gpp.get_kid())
        gpp.set_key(key)
        verified = gpp.verify()

        if verified:
            output.add_general_info_ok(k.get_verified()[1], verified)
        else:
            output.add_general_info_error(k.get_verified()[1], verified)

        unknown_cert = gpp.certificate_type not in (
                k.get_vaccine()[1],
                k.get_test()[1],
                k.get_recovery()[1]
        )

        valid = verified and not expired and not positive and not unknown_cert
        # Unix return code is inverted
        return 1 - valid

if __name__=="__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--qr",          help="qrcodefile, png format")
    parser.add_argument("--pdf",         help="qrcodefile, pdf format")
    parser.add_argument("--txt",         help="read qrcode content from file")
    parser.add_argument("--raw",         action="store_true", help="print raw data of certificate in json format")
    parser.add_argument("--settings",    action="store_true", help="Dump settings")
    parser.add_argument("--no-color",    action="store_true", help="Disable color output")
    parser.add_argument("--cachedir",    help="Cache directory, defaults to {}".format(DEFAULT_CACHE_DIR))
    parser.add_argument("--no-cache",    action="store_true", help="Do not use cache")

    args = parser.parse_args()

    txt = args.txt
    raw = args.raw
    qrfile = args.qr
    pdffile = args.pdf
    settings = args.settings
    color = not args.no_color
    cachedir = DEFAULT_CACHE_DIR
    if args.cachedir != None:
        cachedir = args.cachedir

    if args.no_cache:
        cachedir = ''

    res = -1

    if color:
        colorama.init()
        from termcolor import colored
    else:
        # Disable colors
        colored=lambda x,y: x

    sm = SettingsManager(cachedir)

    if qrfile != None:
        (path, filetype) = (qrfile, "png")
    if pdffile != None:
        (path, filetype) = (pdffile, "pdf")
    if txt != None and txt != "":
        (path, filetype) = (txt, "txt")

    if settings != False:
        out = OutputManager()
        out.dump_settings()
        sys.exit(1)

    if txt == None and pdffile == None and qrfile == None and settings == False:
        parser.print_help()
        sys.exit(1)

    data = InputTransformer(path, filetype).get_data()
    gpp = GreenPassParser(data)
    if raw:
        gpp.dump(file=sys.stdout)
        sys.exit(1)

    out = OutputManager()
    logic = LogicManager()
    logic.verify_certificate(out)

    out.dump()
    sys.exit(res)
